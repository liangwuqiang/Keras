<!DOCTYPE html>
    <html><head><meta charset="UTF-8">
    </head><body>
    <p><a href="http://www.tensorfly.cn/tfdoc/tutorials/overview.html">原文链接</a></p>
        <section class="normal" id="section-">
<h1 id="曼德布洛特mandelbrot集合-">曼德布洛特(Mandelbrot)集合 <a class="md-anchor" id="AUTOGENERATED-mandelbrot-set"></a></h1>
<p>虽然可视化曼德布洛特(Mandelbrot)集合与机器学习没有任何关系，但这对于将TensorFlow应用在数学更广泛的领域是一个有趣的例子。实际上，这是tensorflow一个非常直截了当的可视化运用。（我们最终也许会提供一种更加精心设计的运用方式来生成真正更加美丽的图像。）</p>
<p>说明：本教程使用了IPython的notebook。</p>
<h2 id="基本步骤-">基本步骤 <a class="md-anchor" id="AUTOGENERATED-basic-setup"></a></h2>
<p>首先，我们需要导入一些库。</p>
<pre><code class="lang-python"><span class="hljs-comment"># 导入仿真库</span>
<span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np

<span class="hljs-comment"># 导入可视化库</span>
<span class="hljs-keyword">import</span> PIL.Image
<span class="hljs-keyword">from</span> cStringIO <span class="hljs-keyword">import</span> StringIO
<span class="hljs-keyword">from</span> IPython.display <span class="hljs-keyword">import</span> clear_output, Image, display
<span class="hljs-keyword">import</span> scipy.ndimage <span class="hljs-keyword">as</span> nd
</code></pre>
<p>现在我们将定义一个函数来显示迭代计算出的图像。</p>
<pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DisplayFractal</span><span class="hljs-params">(a, fmt=<span class="hljs-string">&amp;apos;jpeg&amp;apos;</span>)</span>:</span>
  <span class="hljs-string">"""显示迭代计算出的彩色分形图像。"""</span>
  a_cyclic = (<span class="hljs-number">6.28</span>*a/<span class="hljs-number">20.0</span>).reshape(list(a.shape)+[<span class="hljs-number">1</span>])
  img = np.concatenate([<span class="hljs-number">10</span>+<span class="hljs-number">20</span>*np.cos(a_cyclic),
                        <span class="hljs-number">30</span>+<span class="hljs-number">50</span>*np.sin(a_cyclic),
                        <span class="hljs-number">155</span>-<span class="hljs-number">80</span>*np.cos(a_cyclic)], <span class="hljs-number">2</span>)
  img[a==a.max()] = <span class="hljs-number">0</span>
  a = img
  a = np.uint8(np.clip(a, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>))
  f = StringIO()
  PIL.Image.fromarray(a).save(f, fmt)
  display(Image(data=f.getvalue()))
</code></pre>
<h2 id="会话（session）和变量（variable）初始化-">会话（session）和变量（variable）初始化 <a class="md-anchor" id="AUTOGENERATED-session-and-variable-initialization"></a></h2>
<p>为了操作的方便，我们常常使用交互式会话（interactive session），但普通会话（regular session）也能正常使用。</p>
<pre><code class="lang-python">   sess = tf.InteractiveSession()
</code></pre>
<p>我们可以自由的混合使用NumPy和TensorFlow，这一点非常方便。</p>
<pre><code class="lang-python"><span class="hljs-comment"># 使用NumPy创建一个在[-2,2]x[-2,2]范围内的2维复数数组</span>

Y, X = np.mgrid[-<span class="hljs-number">1.3</span>:<span class="hljs-number">1.3</span>:<span class="hljs-number">0.005</span>, -<span class="hljs-number">2</span>:<span class="hljs-number">1</span>:<span class="hljs-number">0.005</span>]
Z = X+<span class="hljs-number">1j</span>*Y
</code></pre>
<p>现在我们定义并初始化一组TensorFlow的张量 （tensors）。</p>
<pre><code class="lang-python">xs = tf.constant(Z.astype(<span class="hljs-string">"complex64"</span>))
zs = tf.Variable(xs)
ns = tf.Variable(tf.zeros_like(xs, <span class="hljs-string">"float32"</span>))
</code></pre>
<p>TensorFlow在使用之前需要你明确给定变量的初始值。</p>
<pre><code class="lang-python">tf.initialize_all_variables().run()
</code></pre>
<h2 id="定义并运行计算-">定义并运行计算 <a class="md-anchor" id="AUTOGENERATED-defining-and-running-the-computation"></a></h2>
<p>现在我们指定更多的计算...</p>
<pre><code class="lang-python"><span class="hljs-comment"># 计算一个新值z: z^2 + x</span>
zs_ = zs*zs + xs

<span class="hljs-comment"># 这个新值会发散吗？</span>
not_diverged = tf.complex_abs(zs_) &lt; <span class="hljs-number">4</span>

<span class="hljs-comment"># 更新zs并且迭代计算。</span>
<span class="hljs-comment">#</span>
<span class="hljs-comment"># 说明：在这些值发散之后，我们仍然在计算zs，这个计算消耗特别大！</span>
<span class="hljs-comment">#      如果稍微简单点，这里有更好的方法来处理。</span>
<span class="hljs-comment">#</span>
step = tf.group(
  zs.assign(zs_),
  ns.assign_add(tf.cast(not_diverged, <span class="hljs-string">"float32"</span>))
  )
</code></pre>
<p>...继续执行几百个步骤</p>
<pre><code class="lang-python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">200</span>): step.run()
</code></pre>
<p>让我们看看我们得到了什么。</p>
<pre><code class="lang-python">DisplayFractal(ns.eval())
</code></pre>
<p><img alt="jpeg" src="images/be2317599aaf300bb9c20b37ee8a1a41.jpg"/></p>
<p>结果不错！</p>
<blockquote>
<p>原文：<a href="http://tensorflow.org/tutorials/mandelbrot/index.md" target="_blank">Mandelbrot Set</a>  翻译：<a href="https://github.com/ericxk" target="_blank">ericxk</a>  校对：<a href="https://github.com/tensorfly" target="_blank">tensorfly</a></p>
</blockquote>
</section>
    </body></html>
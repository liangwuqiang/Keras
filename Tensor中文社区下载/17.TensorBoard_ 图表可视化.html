<!DOCTYPE html>
    <html><head><meta charset="UTF-8">
    </head><body>
    <p><a href="http://www.tensorfly.cn/tfdoc/tutorials/overview.html">原文链接</a></p>
        <section class="normal" id="section-">
<h1 id="tensorboard-图表可视化-">TensorBoard: 图表可视化 <a class="md-anchor" id="AUTOGENERATED-tensorboard--graph-visualization"></a></h1>
<p>TensorFlow 图表计算强大而又复杂，图表可视化在理解和调试时显得非常有帮助。 下面是一个运作时的可式化例子。</p>
<p><img alt="一个TensorFlow图表的可视化" src="images/8eb11ae3f5e53932f030d89e14479ed9.gif">
"一个TensorFlow图表的可视化")
<em>一个TensorFlow图表的可视化。</em></img></p>
<p>为了显示自己的图表，需将 TensorBoard 指向此工作的日志目录并运行，点击图表顶部窗格的标签页，然后在左上角的菜单中选择合适的运行。想要深入学习关于如何运行 TensorBoard 以及如何保证所有必要信息被记录下来，请查看 <a href="summaries_and_tensorboard.html">Summaries 和 TensorBoard</a>.</p>
<h2 id="名称域（name-scoping）和节点（node）-">名称域（Name scoping）和节点（Node） <a class="md-anchor" id="AUTOGENERATED-name-scoping-and-nodes"></a></h2>
<p>典型的 TensorFlow 可以有数以千计的节点，如此多而难以一下全部看到，甚至无法使用标准图表工具来展示。为简单起见，我们为变量名划定范围，并且可视化把该信息用于在图表中的节点上定义一个层级。默认情况下， 只有顶层节点会显示。下面这个例子使用<a href="../api_docs/python/framework.html#name_scope"><code>tf.name_scope</code></a>在<code>hidden</code>命名域下定义了三个操作:</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-keyword">with</span> tf.name_scope(<span class="hljs-string">&amp;apos;hidden&amp;apos;</span>) <span class="hljs-keyword">as</span> scope:
  a = tf.constant(<span class="hljs-number">5</span>, name=<span class="hljs-string">&amp;apos;alpha&amp;apos;</span>)
  W = tf.Variable(tf.random_uniform([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], -<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>), name=<span class="hljs-string">&amp;apos;weights&amp;apos;</span>)
  b = tf.Variable(tf.zeros([<span class="hljs-number">1</span>]), name=<span class="hljs-string">&amp;apos;biases&amp;apos;</span>)
</code></pre>
<p>结果是得到了下面三个操作名:</p>
<ul>
<li><em>hidden</em>/alpha</li>
<li><em>hidden</em>/weights</li>
<li><em>hidden</em>/biases</li>
</ul>
<p>默认地，三个操作名会折叠为一个节点并标注为<code>hidden</code>。其额外细节并没有丢失，你可以双击，或点击右上方橙色的<code>+</code>来展开节点，然后就会看到三个子节点<code>alpha</code>，<code>weights</code>和<code>biases</code>了。</p>
<p>这有一个生动的例子，例中有一个更复杂的节点，节点处于其初始和展开状态。</p>
<table width="100%;">
<tr>
<td style="width: 50%;">
<img alt="未展开的名称域" src="images/484f3996bb34392b63a022087878d826.png" title="未展开的名称域">
</img></td>
<td style="width: 50%;">
<img alt="展开的名称域" src="images/420884c89834b18cc068c5764119213d.png" title="展开的名称域">
</img></td>
</tr>
<tr>
<td style="width: 50%;">
      顶级名称域的初始视图<code>pool_1</code>，点击右上方橙色的<code>+</code>按钮或双击节点来展开。
    </td>
<td style="width: 50%;">
      展开的<code>pool_1</code>名称域视图，点击右上方橙色的<code>-</code>按钮或双击节点来收起此名称域。
    </td>
</tr>
</table>
<p>通过名称域把节点分组来得到可读性高的图表很关键的。如果你在构建一个模型，名称域就可以用来控制可视化结果。<strong>你的名称域越好，可视性就越好。</strong></p>
<p>上面的图像例子说明了可视化的另一方面， TensorFlow 图表有两种连接关系：数据依赖和控制依赖。数据依赖显示两个操作之间的tensor流程，用实心箭头指示，而控制依赖用点线表示。在已展开的视图(上面的右图)中，除了用点线连接的<code>CheckNumerics</code>和<code>control_dependency</code>之外，所有连接都是数据依赖的。</p>
<p>还有一种手段用来简化布局。大多数 TensorFlow 图表有一部分节点，这部分节点和其他节点之间有很多连接。比如，许多节点在初始化阶段可能会有一个控制依赖，而绘制所有<code>init</code>节点的边缘和其依赖可能会创造出一个混乱的视图。</p>
<p>为了减少混乱，可视化把所有 high-degree 节点分离到右边的一个<em>从属</em>区域， 而不会绘制线条来表示他们的边缘。线条也不用来表示连接了，我们绘制了小<em>节点图标</em>来指示这些连接关系。分离出从属节点通常不会把关键信息删除掉，因为这些节点和内构功能是相关的。</p>
<table width="100%;">
<tr>
<td style="width: 50%;">
<img alt="conv_1是主图表的部分" src="images/78c9e74fa8a198e3617d04bd94de6652.png" title="conv_1是主图表的部分">
</img></td>
<td style="width: 50%;">
<img alt="save被抽出为从属节点" src="images/cd3964342567b935bfa7763555f5ab62.png" title="save被抽出为从属节点">
</img></td>
</tr>
<tr>
<td style="width: 50%;">
      节点<code>conv_1</code>被连接到<code>save</code>，注意其右边<code>save</code>节点图标。
    </td>
<td style="width: 50%;">
<code>save</code> has a high degree, 并会作为从属节点出现，与<code>conv_1</code>的连接作为一个节点图标显示在其左边。为了继续减少杂乱，既然<code>save</code>有很多连接，我们则只显示前5个，而把其余的缩略为<code>... 12 more</code>。
    </td>
</tr>
</table>
<p>最后一个结构上的简化法叫做<em>序列折叠（series collapsing）</em>。 序列基序（Sequential motifs）是拥有相同结构并且其名称结尾的数字不同的节点，它们被折叠进一个单独的节点块（stack）中。对长序列网络来说，序列折叠极大地简化了视图，对于已层叠的节点，双击会展开序列。</p>
<table width="100%;">
<tr>
<td style="width: 50%;">
<img alt="节点序列" src="images/fea217e33da3dc2d69e65fa17b11987a.png" title="节点序列">
</img></td>
<td style="width: 50%;">
<img alt="展开的节点序列" src="images/e193768e716fd1344d99fbf9126f3186.png" title="展开的节点序列">
</img></td>
</tr>
<tr>
<td style="width: 50%;">
      一个节点序列的折叠视图。
    </td>
<td style="width: 50%;">
      视图的一小块, 双击后展开。
    </td>
</tr>
</table>
<p>最后，针对易读性的最后一点要说到的是，可视化为常节点和摘要节点使用了特别的图标，总结起来有下面这些节点符号：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><img alt="名称域" src="images/dc0b7b4a516c413f0b3c15b2b71aa0aa.png" title="名称域"/></td>
<td><em>High-level</em>节点代表一个名称域，双击则展开一个高层节点。</td>
</tr>
<tr>
<td><img alt="断线节点序列" src="images/5cdfc7d17e6f8b36fc15fafb7e886dfb.png" title="断线节点序列"/></td>
<td>彼此之间不连接的有限个节点序列。</td>
</tr>
<tr>
<td><img alt="相连节点序列" src="images/afd08e7507245fff17ead9e252f0588c.png" title="相连节点序列"/></td>
<td>彼此之间相连的有限个节点序列。</td>
</tr>
<tr>
<td><img alt="操作节点" src="images/7e4e884365dccc8d2167ab9c9482c5f2.png" title="操作节点"/></td>
<td>一个单独的操作节点。</td>
</tr>
<tr>
<td><img alt="常量节点" src="images/1769a947afd50b032b81353ee338645b.png" title="常量节点"/></td>
<td>一个常量结点。</td>
</tr>
<tr>
<td><img alt="摘要节点" src="images/2891ad94997df83e04ca2ffdec6d65b3.png" title="摘要节点"/></td>
<td>一个摘要节点。</td>
</tr>
<tr>
<td><img alt="数据流边" src="images/19030b0dd85e7e8ccbd5f1c26acf6ef9.png" title="数据流边"/></td>
<td>显示各操作间的数据流边。</td>
</tr>
<tr>
<td><img alt="控制依赖边" src="images/eb8ead8ac31c0c915293c76354a633da.png" title="控制依赖边"/></td>
<td>显示各操作间的控制依赖边。</td>
</tr>
<tr>
<td><img alt="引用边" src="images/fc4a6ea642e86090999a3e2cfc650583.png" title="引用边"/></td>
<td>引用边，表示出度操作节点可以使入度tensor发生变化。</td>
</tr>
</tbody>
</table>
<h2 id="交互-">交互 <a class="md-anchor" id="AUTOGENERATED-interaction"></a></h2>
<p>通过平移和缩放来导航图表，点击和拖动用于平移，滚动手势用于缩放。双击一个节点或点击其<code>+</code>按钮来展开代表一组操作的名称域。右下角有一个小地图可以在缩放和平移时方便的改变当前视角。</p>
<p>要关闭一个打开的节点，再次双击它或点击它的<code>-</code>按钮，你也可以只点击一次来选中一个节点，节点的颜色会加深，并且会看到节点的详情，其连接到的节点会在可视化右上角的详情卡片显现。</p>
<table width="100%;">
<tr>
<td style="width: 50%;">
<img alt="一个名称域的详情卡片" src="images/44f4ebacf6adda581b61b986ba7f858a.png" title="一个名称域的详情卡片">
</img></td>
<td style="width: 50%;">
<img alt="操作节点的详情卡片" src="images/440c5ddd446b1880b9e1c6000f290a2d.png" title="操作节点的详情卡片">
</img></td>
</tr>
<tr>
<td style="width: 50%;">
      详情卡片展示<code>conv2</code>名称域的详细信息，名称域中操作节点的输入和输出被结合在一起，适用于不显示属性的名称域。
    </td>
<td style="width: 50%;">
      详情卡片展示<code>DecodeRaw</code>操作节点，除了输入和输出，卡片也会展示与当前节点相关的设备和属性。
    </td>
</tr>
</table>
<p>选择对于 high-degree 节点的理解也很有帮助，选择任意节点，则与它的其余连接相应的节点也会选中，这使得在进行例如查看哪一个节点是否已保存等操作时非常容易。</p>
<p>点击详情卡片中的一个节点名称时会选中该节点，必要的话，视角会自动平移以使该节点可见。</p>
<p>最后，使用图例上方的颜色菜单，你可以给你的图表选择两个颜色方案。默认的<em>结构视图</em>下，当两个 high-level 节点颜色一样时，其会以相同的彩虹色彩出现，而结构唯一的节点颜色是灰色。还有一个视图则展示了不同的操作运行于什么设备之上。名称域被恰当的根据其中的操作节点的设备片件来着色。</p>
<p>下图是一张真实图表的图解：</p>
<table width="100%;">
<tr>
<td style="width: 50%;">
<img alt="按结构着色" src="images/eb03b9252b2ee13cdccd4251983a32f7.png" title="按结构着色">
</img></td>
<td style="width: 50%;">
<img alt="按设备着色" src="images/42cf78ebfb7be04ecb979094e4e073cc.png" title="按设备着色">
</img></td>
</tr>
<tr>
<td style="width: 50%;">
      结构视图：灰色节点的结构是唯一的。橙色的<code>conv1</code>和<code>conv2</code>节点有相同的结构, 其他颜色的节点也类似。
    </td>
<td style="width: 50%;">
      设备视图：名称域根据其中的操作节点的设备片件来着色，在此紫色代表GPU，绿色代表CPU。
    </td>
</tr>
</table>
<p>原文: <a href="https://www.tensorflow.org/versions/master/how_tos/graph_viz/index.html" target="_blank">TensorBoard: Graph Visualization</a>
翻译: <a href="https://github.com/Warln" target="_blank">@Warln</a>  校对: <a href="https://github.com/lucky521" target="_blank">lucky521</a></p>
</section>
    </body></html>
<!DOCTYPE html>
    <html><head><meta charset="UTF-8">
    </head><body>
    <p><a href="http://wiki.jikexueyuan.com/project/tensorflow-zh/">原文链接</a></p>
        <div class="markdown-body">
<!-- 欢迎成为极客学院WIKI作者 -->
<!-- 极客学院团队出品 -->
<p class="author">极客学院团队出品 · 更新于 2017-10-13 11:00:26</p>
<!-- 内容 -->
<h1>曼德布洛特(Mandelbrot)集合 <a class="md-anchor" id="AUTOGENERATED-mandelbrot-set"></a></h1>
<p>虽然可视化曼德布洛特(Mandelbrot)集合与机器学习没有任何关系，但这对于将TensorFlow应用在数学更广泛的领域是一个有趣的例子。实际上，这是tensorflow一个非常直截了当的可视化运用。（我们最终也许会提供一种更加精心设计的运用方式来生成真正更加美丽的图像。）</p>
<p>说明：本教程使用了IPython的notebook。</p>
<h2 id="ba78c7c837c9b5de0a7a78f91da1cf17">基本步骤 <a class="md-anchor" id="AUTOGENERATED-basic-setup"></a></h2>
<p>首先，我们需要导入一些库。</p>
<pre><code class="language-python"># 导入仿真库
import tensorflow as tf
import numpy as np

# 导入可视化库
import PIL.Image
from cStringIO import StringIO
from IPython.display import clear_output, Image, display
import scipy.ndimage as nd</code></pre>
<p>现在我们将定义一个函数来显示迭代计算出的图像。</p>
<pre><code class="language-python">def DisplayFractal(a, fmt='jpeg'):
  """显示迭代计算出的彩色分形图像。"""
  a_cyclic = (6.28*a/20.0).reshape(list(a.shape)+[1])
  img = np.concatenate([10+20*np.cos(a_cyclic),
                        30+50*np.sin(a_cyclic),
                        155-80*np.cos(a_cyclic)], 2)
  img[a==a.max()] = 0
  a = img
  a = np.uint8(np.clip(a, 0, 255))
  f = StringIO()
  PIL.Image.fromarray(a).save(f, fmt)
  display(Image(data=f.getvalue()))</code></pre>
<h2 id="9a70ac0ce3c291ed7243a79eeeb0e3b7">会话（session）和变量（variable）初始化 <a class="md-anchor" id="AUTOGENERATED-session-and-variable-initialization"></a></h2>
<p>为了操作的方便，我们常常使用交互式会话（interactive session），但普通会话（regular session）也能正常使用。</p>
<pre><code class="language-python">   sess = tf.InteractiveSession()</code></pre>
<p>我们可以自由的混合使用NumPy和TensorFlow，这一点非常方便。</p>
<pre><code class="language-python"># 使用NumPy创建一个在[-2,2]x[-2,2]范围内的2维复数数组

Y, X = np.mgrid[-1.3:1.3:0.005, -2:1:0.005]
Z = X+1j*Y</code></pre>
<p>现在我们定义并初始化一组TensorFlow的张量 （tensors）。</p>
<pre><code class="language-python">xs = tf.constant(Z.astype("complex64"))
zs = tf.Variable(xs)
ns = tf.Variable(tf.zeros_like(xs, "float32"))</code></pre>
<p>TensorFlow在使用之前需要你明确给定变量的初始值。</p>
<pre><code class="language-python">tf.initialize_all_variables().run()</code></pre>
<h2 id="472ee6e9075fcd6374a7d3446d322338">定义并运行计算 <a class="md-anchor" id="AUTOGENERATED-defining-and-running-the-computation"></a></h2>
<p>现在我们指定更多的计算...</p>
<pre><code class="language-python"># 计算一个新值z: z^2 + x
zs_ = zs*zs + xs

# 这个新值会发散吗？
not_diverged = tf.complex_abs(zs_) &lt; 4

# 更新zs并且迭代计算。
#
# 说明：在这些值发散之后，我们仍然在计算zs，这个计算消耗特别大！
#      如果稍微简单点，这里有更好的方法来处理。
#
step = tf.group(
  zs.assign(zs_),
  ns.assign_add(tf.cast(not_diverged, "float32"))
  )</code></pre>
<p>...继续执行几百个步骤</p>
<pre><code class="language-python">for i in range(200): step.run()</code></pre>
<p>让我们看看我们得到了什么。</p>
<pre><code class="language-python">DisplayFractal(ns.eval())</code></pre>
<p><img alt="jpeg" src="images/478ff82ce640682f404bac1d6b222e80.jpg"/></p>
<p>结果不错！</p>
<blockquote>
<p>原文：<a "="" href="http://tensorflow.org/tutorials/mandelbrot/index.md" rel="nofollow">Mandelbrot Set</a>  翻译：<a "="" href="https://github.com/ericxk" rel="nofollow">ericxk</a>  校对：<a "="" href="https://github.com/tensorfly" rel="nofollow">tensorfly</a></p>
</blockquote>
</div>
    </body></html>
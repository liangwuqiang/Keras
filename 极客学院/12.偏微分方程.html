<!DOCTYPE html>
    <html><head><meta charset="UTF-8">
    </head><body>
    <p><a href="http://wiki.jikexueyuan.com/project/tensorflow-zh/">原文链接</a></p>
        <div class="markdown-body">
<!-- 欢迎成为极客学院WIKI作者 -->
<!-- 极客学院团队出品 -->
<p class="author">极客学院团队出品 · 更新于 2017-10-13 11:00:26</p>
<!-- 内容 -->
<h1>偏微分方程 <a class="md-anchor" id="AUTOGENERATED-partial-differential-equations"></a></h1>
<p><strong><em>TensorFlow</em></strong> 不仅仅是用来机器学习，它更可以用来模拟仿真。在这里，我们将通过模拟仿真几滴落入一块方形水池的雨点的例子，来引导您如何使用 <strong><em>TensorFlow</em></strong> 中的偏微分方程来模拟仿真的基本使用方法。</p>
<blockquote>
<p>注：本教程最初是准备做为一个 <strong>IPython</strong> 的手册。</p>
<blockquote>
<p>译者注:关于偏微分方程的相关知识，译者推荐读者查看 <a "="" href="http://open.163.com/" rel="nofollow"><strong>网易公开课</strong></a> 上的<a "="" href="http://open.163.com/special/opencourse/multivariable.html" rel="nofollow"><strong>《麻省理工学院公开课：多变量微积分》</strong></a>课程。</p>
</blockquote>
</blockquote>
<h2 id="697e5ac7aef0823742e09a8ac21c6a33">基本设置 <a class="md-anchor" id="AUTOGENERATED-basic-setup"></a></h2>
<p>首先,我们需要导入一些必要的引用。</p>
<pre><code class="language-python">#导入模拟仿真需要的库
import tensorflow as tf
import numpy as np

#导入可视化需要的库
import PIL.Image
from cStringIO import StringIO
from IPython.display import clear_output, Image, display</code></pre>
<p>然后，我们还需要一个用于表示池塘表面状态的函数。</p>
<pre><code class="language-python">def DisplayArray(a, fmt='jpeg', rng=[0,1]):
  """Display an array as a picture."""
  a = (a - rng[0])/float(rng[1] - rng[0])*255
  a = np.uint8(np.clip(a, 0, 255))
  f = StringIO()
  PIL.Image.fromarray(a).save(f, fmt)
  display(Image(data=f.getvalue()))</code></pre>
<p>最后，为了方便演示，这里我们需要打开一个 <strong><em>TensorFlow</em></strong> 的交互会话（interactive session）。当然为了以后能方便调用，我们可以把相关代码写到一个可以执行的<strong><em>Python</em></strong>文件中。</p>
<pre><code class="language-python">sess = tf.InteractiveSession()</code></pre>
<h2 id="bbcb409583ab6c0f553772aab07622c8">定义计算函数 <a class="md-anchor" id="AUTOGENERATED-computational-convenience-functions"></a></h2>
<pre><code class="language-python">def make_kernel(a):
  """Transform a 2D array into a convolution kernel"""
  a = np.asarray(a)
  a = a.reshape(list(a.shape) + [1,1])
  return tf.constant(a, dtype=1)

def simple_conv(x, k):
  """A simplified 2D convolution operation"""
  x = tf.expand_dims(tf.expand_dims(x, 0), -1)
  y = tf.nn.depthwise_conv2d(x, k, [1, 1, 1, 1], padding='SAME')
  return y[0, :, :, 0]

def laplace(x):
  """Compute the 2D laplacian of an array"""
  laplace_k = make_kernel([[0.5, 1.0, 0.5],
                           [1.0, -6., 1.0],
                           [0.5, 1.0, 0.5]])
  return simple_conv(x, laplace_k)</code></pre>
<h2 id="8788ffdb5bf445379a6876f21ee62346">定义偏微分方程 <a class="md-anchor" id="AUTOGENERATED-define-the-pde"></a></h2>
<p>首先,我们需要创建一个完美的 500 × 500 的正方形池塘,就像是我们在现实中找到的一样。</p>
<pre><code class="language-python">N = 500</code></pre>
<p>然后，我们需要创建了一个池塘和几滴将要坠入池塘的雨滴。</p>
<pre><code class="language-python"># Initial Conditions -- some rain drops hit a pond

# Set everything to zero
u_init = np.zeros([N, N], dtype="float32")
ut_init = np.zeros([N, N], dtype="float32")

# Some rain drops hit a pond at random points
for n in range(40):
  a,b = np.random.randint(0, N, 2)
  u_init[a,b] = np.random.uniform()

DisplayArray(u_init, rng=[-0.1, 0.1])</code></pre>
<p><img alt="jpeg" src="images/fecdae91ad9034d6182c66608fd64f02.jpg"/></p>
<p>现在，让我们来指定该微分方程的一些详细参数。</p>
<pre><code class="language-python"># Parameters:
# eps -- time resolution
# damping -- wave damping
eps = tf.placeholder(tf.float32, shape=())
damping = tf.placeholder(tf.float32, shape=())

# Create variables for simulation state
U  = tf.Variable(u_init)
Ut = tf.Variable(ut_init)

# Discretized PDE update rules
U_ = U + eps * Ut
Ut_ = Ut + eps * (laplace(U) - damping * Ut)

# Operation to update the state
step = tf.group(
  U.assign(U_),
  Ut.assign(Ut_))</code></pre>
<h2 id="95a4ae35fdb6f282ed1cce3bd6ad5d97">开始仿真 <a class="md-anchor" id="AUTOGENERATED-run-the-simulation"></a></h2>
<p>为了能看清仿真效果，我们可以用一个简单的 <strong>for</strong> 循环来远行我们的仿真程序。</p>
<pre><code class="language-python"># Initialize state to initial conditions
tf.initialize_all_variables().run()

# Run 1000 steps of PDE
for i in range(1000):
  # Step simulation
  step.run({eps: 0.03, damping: 0.04})
  # Visualize every 50 steps
  if i % 50 == 0:
    clear_output()
    DisplayArray(U.eval(), rng=[-0.1, 0.1])</code></pre>
<p><img alt="jpeg" src="images/4ba41169e26ed5782c144c5ef57c63d8.jpg"/></p>
<p>看！！ 雨点落在池塘中,和现实中一样的泛起了涟漪。</p>
<blockquote>
<p>原文链接:<a "="" href="http://tensorflow.org/tutorials/pdes/index.md" rel="nofollow"><a "="" href="http://tensorflow.org/tutorials/pdes/index.md" rel="nofollow">http://tensorflow.org/tutorials/pdes/index.md</a></a>    翻译:<a "="" href="https://github.com/wangaicc" rel="nofollow">@wangaicc</a>   校对:<a "="" href="https://github.com/tensorfly" rel="nofollow">@tensorfly</a></p>
</blockquote>
</div>
    </body></html>
<!DOCTYPE html>
    <html><head><meta charset="UTF-8">
    </head><body>
    <p><a href="http://wiki.jikexueyuan.com/project/tensorflow-zh/">原文链接</a></p>
        <div class="markdown-body">
<!-- 欢迎成为极客学院WIKI作者 -->
<!-- 极客学院团队出品 -->
<p class="author">极客学院团队出品 · 更新于 2017-10-13 11:00:26</p>
<!-- 内容 -->
<h1>增加一个新 Op <a class="md-anchor" id="AUTOGENERATED-adding-a-new-op"></a></h1>
<p>预备知识:</p>
<ul>
<li>对 C++ 有一定了解.</li>
<li>已经<a #source="" href="tensorflow-zh/SOURCE/get_started/introduction.html">下载 TensorFlow 源代码</a>并有能力编译它.</li>
</ul>
<p>如果现有的库没有涵盖你想要的操作, 你可以自己定制一个. 为了使定制的 Op 能够兼容原有的库
, 你必须做以下工作:</p>
<ul>
<li>在一个 C++ 文件中注册新 Op. Op 的注册与实现是相互独立的. 在其注册时描述了 Op 该如何执行.
例如, 注册 Op 时定义了 Op 的名字, 并指定了它的输入和输出.</li>
<li>使用 C++ 实现 Op. 每一个实现称之为一个 "kernel", 可以存在多个 kernel, 以适配不同的架构
(CPU, GPU 等)或不同的输入/输出类型.</li>
<li>创建一个 Python 包装器（wrapper）. 这个包装器是创建 Op 的公开 API. 当注册 Op 时, 会自动生成一个默认
默认的包装器. 既可以直接使用默认包装器, 也可以添加一个新的包装器. </li>
<li>(可选) 写一个函数计算 Op 的梯度.</li>
<li>(可选) 写一个函数, 描述 Op 的输入和输出 shape. 该函数能够允许从 Op 推断 shape.</li>
<li>测试 Op, 通常使用 Pyhton。如果你定义了梯度，你可以使用Python的<a "="" href="https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/python/kernel_tests/gradient_checker.py" rel="nofollow">GradientChecker</a>来测试它。</li>
</ul>
<!-- TOC-BEGIN This section is generated by neural network: DO NOT EDIT! -->
<h2 id="2d711b09bd0db0ad240cc83b30dd8014">内容</h2>
<h3><a href="#AUTOGENERATED-adding-a-new-op">增加一个新 Op</a></h3>
<ul>
<li><a href="#define_interface">定义 Op 的接口</a></li>
<li><a href="#AUTOGENERATED-implement-the-kernel-for-the-op">为 Op 实现 kernel</a></li>
<li><a href="#AUTOGENERATED-generate-the-client-wrapper">生成客户端包装器</a>
<ul>
<li><a href="#AUTOGENERATED-the-python-op-wrapper">Python Op 包装器</a></li>
<li><a href="#AUTOGENERATED-the-c---op-wrapper">C++ Op 包装器</a></li>
</ul></li>
<li><a href="#AUTOGENERATED-verify-it-works">检查 Op 能否正常工作</a></li>
<li><a href="#Validation">验证条件</a></li>
<li><a href="#AUTOGENERATED-op-registration">Op 注册</a>
<ul>
<li><a href="#Attrs">属性</a></li>
<li><a href="#AUTOGENERATED-attr-types">属性类型</a></li>
<li><a href="#Polymorphism">多态</a></li>
<li><a href="#AUTOGENERATED-inputs-and-outputs">输入和输出</a></li>
<li><a href="#AUTOGENERATED-backwards-compatibility">向后兼容性</a></li>
</ul></li>
<li><a href="#mult-archs">GPU 支持</a></li>
<li><a href="#AUTOGENERATED-implement-the-gradient-in-python">使用 Python 实现梯度</a></li>
<li><a href="#AUTOGENERATED-implement-a-shape-function-in-python">使用 Python 实现 shape 函数</a></li>
</ul>
<!-- TOC-END This section was generated by neural network, THANKS FOR READING! -->
<h2 id="cee4408ca4f5eec13082ed322a9516ae">定义 Op 的接口 <a class="md-anchor" id="define_interface"></a></h2>
<p>向 TensorFlow 系统注册来定义 Op 的接口. 在注册时, 指定 Op 的名称, 它的输入(类型和名称)
和输出(类型和名称), 和所需要任何 <a href="#Attrs">属性</a>的文档说明.</p>
<p>为了让你有直观的认识, 创建一个简单的 Op 作为例子. 该 Op 接受一个 <code>int32</code> 类型 tensor 作为
输入, 输出这个 tensor 的一个副本, 副本与原 tensor 唯一的区别在于第一个元素被置为 0. 创建
文件 <code>tensorflow/core/user_ops/zero_out.cc</code>, 并调用 <code>REGISTER_OP</code> 宏来定义 Op 的接口.</p>
<pre><code> #include "tensorflow/core/framework/op.h"
REGISTER_OP("ZeroOut")
    .Input("to_zero: int32")
    .Output("zeroed: int32");</code></pre>
<p><code>ZeroOut</code> Op 接受 32 位整型的 tensor <code>to_zero</code> 作为输入, 输出 32 位整型的 tensor <code>zeroed</code>.</p>
<blockquote>
<p>命名的注意事项: Op 的名称必须是为唯一的, 并使用驼峰命名法. 以下划线 <code>_</code> 开始的名称保留为内部使用.</p>
</blockquote>
<h2 id="8164c1aff244c95b639cfcb0b33b1cd8">为 Op 实现 kernel <a class="md-anchor" id="AUTOGENERATED-implement-the-kernel-for-the-op"></a></h2>
<p>在定义接口之后, 提供一个或多个 Op 的实现. 为这些 kernel 的每一个创建一个对应的类, 继承
<code>OpKernel</code>, 覆盖 <code>Compute</code> 方法. <code>Compute</code> 方法提供一个类型为 <code>OpKernelContext*</code> 的参数 <code>context</code>, 用于访问一些有用的信息, 例如输入和输出的 tensor. </p>
<p>将 kernel 添加到刚才创建的文件中, kernel 看起来和下面的代码类似:</p>
<pre><code> #include "tensorflow/core/framework/op_kernel.h"
using namespace tensorflow;
class ZeroOutOp : public OpKernel {
 public:
  explicit ZeroOutOp(OpKernelConstruction* context) : OpKernel(context) {}
  void Compute(OpKernelContext* context) override {
    // 获取输入 tensor.
    const Tensor&amp; input_tensor = context-&gt;input(0);
    auto input = input_tensor.flat&lt;int32&gt;();
   // 创建一个输出 tensor.
    Tensor* output_tensor = NULL;
    OP_REQUIRES_OK(context, context-&gt;allocate_output(0, input_tensor.shape(),
                                                     &amp;output_tensor));
    auto output = output_tensor-&gt;template flat&lt;int32&gt;();
    // 设置 tensor 除第一个之外的元素均设为 0.
    const int N = input.size();
    for (int i = 1; i &lt; N; i++) {
      output(i) = 0;
    }
    // 尽可能地保留第一个元素的值.
    if (N &gt; 0) output(0) = input(0);
  }
};</code></pre>
<p>实现 kernel 后, 将其注册到 TensorFlow 系统中. 注册时, 可以指定该 kernel 运行时的多个约束
条件. 例如可以指定一个 kernel 在 CPU 上运行, 另一个在 GPU 上运行.</p>
<p>将下列代码加入到 <code>zero_out.cc</code> 中, 注册 <code>ZeroOut</code> op:</p>
<pre><code>REGISTER_KERNEL_BUILDER(Name("ZeroOut").Device(DEVICE_CPU), ZeroOutOp);</code></pre>
<p>一旦<a #create-pip="" href="tensorflow-zh/SOURCE/get_started/os_setup.html">创建和重新安装了 TensorFlow </a>,
Tensorflow 系统可以在需要时引用和使用该 Op.</p>
<h2 id="6d0c6091c1f7d3217997641cf36d91fb">生成客户端包装器 <a class="md-anchor" id="AUTOGENERATED-generate-the-client-wrapper"></a></h2>
<h3>Python Op 包装器 <a class="md-anchor" id="AUTOGENERATED-the-python-op-wrapper"></a></h3>
<p>当编译 TensorFlow 时, 所有放在 <a "="" href="https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/user_ops/" rel="nofollow"><code>tensorflow/core/user_ops</code></a> 目录下
的 Op 会自动在 <code>bazel-genfiles/tensorflow/python/ops/gen_user_ops.py</code> 文件
中生成 Python Op 包装器. 通过以下声明, 把那些 Op 引入到 <a "="" href="https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/python/user_ops/user_ops.py" rel="nofollow"><code>tensorflow/python/user_ops/user_ops.py</code></a>
中:</p>
<pre><code class="language-python">from tensorflow.python.ops.gen_user_ops import *</code></pre>
<p>你可以选择性将部分函数替换为自己的实现. 为此, 首先要隐藏自动生成的代码,
在 <a "="" href="https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/python/BUILD" rel="nofollow"><code>tensorflow/python/BUILD</code></a>
文件中, 将其名字添加到 <code>"user_ops"</code> 的 <code>hidden</code> 列表.</p>
<pre><code class="language-python">tf_gen_op_wrapper_py(
    name = "user_ops",
    hidden = [
        "Fact",
    ],
    require_shape_functions = False,
)</code></pre>
<p>紧接着 <code>"Fact"</code> 列出自己的 Op. 然后, 在
<a "="" href="https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/python/user_ops/user_ops.py" rel="nofollow"><code>tensorflow/python/user_ops/user_ops.py</code></a>
中添加你的替代实现函数. 通常, 替代实现函数也会调用自动生成函数来真正把 Op 添加
到图中. 被隐藏的自动生成函数位于 <code>gen_user_ops</code> 包中, 名称多了一个下划线前缀
("<code>_</code>"). 例如:</p>
<pre><code class="language-python">def my_fact():
    """覆盖一个 Op 自动生成代码的示例."""
    return gen_user_ops._fact()</code></pre>
<h3>C++ Op 包装器 <a class="md-anchor" id="AUTOGENERATED-the-c---op-wrapper"></a></h3>
<p>当编译 TensorFlow 时, 所有 <a "="" href="https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/user_ops/" rel="nofollow"><code>tensorflow/core/user_ops</code></a> 文件夹
下的 Op 会自动创建 C++ Op 包装器. 例如, <code>tensorflow/core/user_ops/zero_out.cc</code> 中的 Op 会自动在 <code>bazel-genfiles/tensorflow/cc/ops/user_ops.{h,cc}</code>
中生成包装器.</p>
<p><a "="" href="https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/cc/ops/standard_ops.h" rel="nofollow"><code>tensorflow/cc/ops/standard_ops.h</code></a> 通过下述申明,
导入用户自定义 Op 自动生成的包装器.</p>
<pre><code> #include "tensorflow/cc/ops/user_ops.h"</code></pre>
<h2 id="1051e24084b9e48e2b50bd56ca31d9ee">检查 Op 能否正常工作 <a class="md-anchor" id="AUTOGENERATED-verify-it-works"></a></h2>
<p>验证已经成功实现 Op 的方式是编写测试程序. 创建文件
<code>tensorflow/python/kernel_tests/zero_out_op_test.py</code>,
包含以下内容:</p>
<pre><code class="language-python">import tensorflow as tf
class ZeroOutTest(tf.test.TestCase):
  def testZeroOut(self):
    with self.test_session():
      result = tf.user_ops.zero_out([5, 4, 3, 2, 1])
      self.assertAllEqual(result.eval(), [5, 0, 0, 0, 0])</code></pre>
<p>然后运行测试:</p>
<pre><code class="language-sh">$ bazel test tensorflow/python:zero_out_op_test</code></pre>
<h2 id="4d16625835c94c9debb16ccf90dd2f35">验证条件 <a class="md-anchor" id="Validation"></a></h2>
<p>上述示例假定 Op 能够应用在任何 shape 的 tensor 上. 如果只想应用到 vector 上
呢?
这意味需要在上述 OpKernel 实现中添加相关的检查.</p>
<pre><code>  void Compute(OpKernelContext* context) override {
   // 获取输入 tensor
    const Tensor&amp; input_tensor = context-&gt;input(0);
    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_tensor.shape()),
                errors::InvalidArgument("ZeroOut expects a 1-D vector."));
    // ...
  }</code></pre>
<p>OP_REQUIRES 断言的输入是一个 vector, 如果不是 vector, 将设置 <code>InvalidArgument</code> 状态并返回.
<a "="" href="https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/lib/core/errors.h" rel="nofollow"><code>OP_REQUIRES</code> 宏</a> 有三个参数:</p>
<ul>
<li><code>context</code>: 可以是一个 <code>OpKernelContext</code> 或 <code>OpKernelConstruction</code> 指针
(参见 <a "="" href="https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/framework/op_kernel.h" rel="nofollow"><code>tensorflow/core/framework/op_kernel.h</code></a>),
其 <code>SetStatus()</code> 方法将被使用到.</li>
<li>检查条件: <a "="" href="https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/public/tensor_shape.h" rel="nofollow"><code>tensorflow/core/public/tensor_shape.h</code></a>
中有一些验证 tensor shape 的函数.</li>
<li>条件不满足时产生的错误: 错误用一个 <code>Status</code> 对象表示, 参见
<a "="" href="https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/public/status.h" rel="nofollow"><code>tensorflow/core/public/status.h</code></a>.
<code>Status</code> 包含一个类型 (通常是 <code>InvalidArgument</code>, 但也可以是任何类型) 和一个消息. 构造
一个错误的函数位于 <a "="" href="https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/lib/core/errors.h" rel="nofollow"><code>tensorflow/core/lib/core/errors.h</code></a> 中.</li>
</ul>
<p>如果想要测试一个函数返回的 <code>Status</code> 对象是否是一个错误, 可以使用 <a "="" href="https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/lib/core/errors.h" rel="nofollow"><code>OP_REQUIRES_OK</code></a>.
这些宏如果检测到错误, 会直接跳出函数, 终止函数执行.</p>
<h2 id="c87eef9e48c970c58001fc4575f884ca">Op 注册 <a class="md-anchor" id="AUTOGENERATED-op-registration"></a></h2>
<h3>属性 <a class="md-anchor" id="Attrs"></a></h3>
<p>Op 可以有属性, 属性的值在 Op 添加到图中时被设置. 属性值用于配置 Op, 在 kernel 实现中, Op 注册的输入和输出类型中, 均可访问这些属性值. 尽可能地使用输入代替属性, 因为输入的灵活性更高, 例如可以在执行步骤中
中被更改, 可以使用 feed 等等. 属性可用于实现一些输入无法做到的事情, 例如影响 Op 签名 (即输入输出的数量和类型)
的配置或只读配置可以通过属性实现.</p>
<p>注册 Op 时可以用 <code>Attr</code> 方法指定属性的名称和类型, 以此来定义一个属性, 形式如下:</p>
<pre><code>&lt;name&gt;: &lt;attr-type-expr&gt;</code></pre>
<p><code>&lt;name&gt;</code> 必须以字母开头, 可以由数字, 字母, 下划线组成. <code>&lt;attr-type-expr&gt;</code> 是一个类型表达式,
形式<a href="#attr-types">如下</a>:</p>
<p>例如, 如果想要 <code>ZeroOut</code> Op 保存一个用户索引, 指示该 Op 不仅仅只有一个元素, 你可以注册 Op 如下:</p>
<pre><code>REGISTER_OP("ZeroOut")
    .Attr("preserve_index: int")
    .Input("to_zero: int32")
    .Output("zeroed: int32");</code></pre>
<p>你的 kernel 可以在构造函数里, 通过 <code>context</code> 参数访问这个属性:</p>
<pre><code>class ZeroOutOp : public OpKernel {
 public:
  explicit ZeroOutOp(OpKernelConstruction * context) : OpKernel(context) {
   // 获取欲保存的索引值
    OP_REQUIRES_OK(context,
                   context-&gt;GetAttr("preserve_index", &amp;preserve_index_));
    // 检查 preserve_index 是否为正
    OP_REQUIRES(context, preserve_index_ &gt;= 0,
                errors::InvalidArgument("Need preserve_index &gt;= 0, got ",
                                        preserve_index_));
  }
  void Compute(OpKernelContext* context) override {
    // ...
}
 private:
  int preserve_index_;
};</code></pre>
<p>该值可以在 <code>Compute</code> 方法中被使用:</p>
<pre><code>void Compute(OpKernelContext* context) override {
    // ...
   // 检查 preserve_index 范围是否合法
OP_REQUIRES(context, preserve_index_ &lt; input.dimension(0),
                errors::InvalidArgument("preserve_index out of range"));
    // 设置输出 tensor 所有的元素值为 0
   const int N = input.size();
    for (int i = 0; i &lt; N; i++) {
      output_flat(i) = 0;
    }
    // 保存请求的输入值
   output_flat(preserve_index_) = input(preserve_index_);
  }</code></pre>
<blockquote>
<p>为了维持<a href="#backwards-compatibility">向后兼容性</a>, 将一个属性添加到一个已有的 Op 时,
必须指定一个<a href="#default-values-constraints">默认值</a>:</p>
</blockquote>
<pre><code>REGISTER_OP("ZeroOut")
     .Attr("preserve_index: int = 0")
     .Input("to_zero: int32")
     .Output("zeroed: int32");</code></pre>
<h3>属性类型 <a class="md-anchor" id="AUTOGENERATED-attr-types"></a></h3>
<p>属性可以使用下面的类型:</p>
<ul>
<li><code>string</code>: 任何二进制字节流 (UTF8 不是必须的).</li>
<li><code>int</code>: 一个有型整数.</li>
<li><code>float</code>: 一个浮点数.</li>
<li><code>bool</code>: 真或假.</li>
<li><code>type</code>: <a "="" href="https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/framework/types.cc#DataTypeString" rel="nofollow"><code>DataType</code></a> 非引用类型之一.</li>
<li><code>shape</code>: 一个 <a "="" href="https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/framework/tensor_shape.proto" rel="nofollow"><code>TensorShapeProto</code></a>.</li>
<li><code>tensor</code>: 一个 <a "="" href="https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/framework/tensor.proto" rel="nofollow"><code>TensorProto</code></a>.</li>
<li><code>list(&lt;type&gt;)</code>: <code>&lt;type&gt;</code> 列表, 其中 <code>&lt;type&gt;</code> 是上述类型之一.
注意 <code>list(list(&lt;type&gt;))</code> 是无效的.</li>
</ul>
<p>权威的列表以 <a "="" href="https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/framework/op_def_builder.cc#FinalizeAttr" rel="nofollow"><code>op_def_builder.cc:FinalizeAttr</code></a> 为准.</p>
<h4>默认值和约束条件 <a class="md-anchor" id="AUTOGENERATED-default-values---constraints"></a></h4>
<p>属性可能有默认值, 一些类型的属性可以有约束条件. 为了定义一个有约束条件的属性, 你可以使用下列的
<code>&lt;attr-type-expr&gt;</code> 形式:</p>
<ul>
<li><code>{'&lt;string1&gt;', '&lt;string2&gt;'}</code>: 属性值必须是一个字符串, 取值可以为 <code>&lt;string1&gt;</code> 或 <code>&lt;string2&gt;</code>.
值的语法已经暗示了值的类型为 <code>string</code>, 已经暗示了. 下述语句模拟了一个枚举值:</li>
</ul>
<pre><code>REGISTER_OP("EnumExample")
      .Attr("e: {'apple', 'orange'}");</code></pre>
<ul>
<li><code>{&lt;type1&gt;, &lt;type2&gt;}</code>: 值是 <code>type</code> 类型, 且必须为 <code>&lt;type1&gt;</code> 或 <code>&lt;type2&gt;</code> 之一, 当然
<code>&lt;type1&gt;</code> 和 <code>&lt;type2&gt;</code> 必须都是有效的 <a #data-types="" href="tensorflow-zh/SOURCE/resources/dims_types.html">tensor 类型</a>.
你无须指定属性的类型为 <code>type</code>, 而是通过 <code>{...}</code> 语句给出一个类型列表. 例如, 在下面的例子里,
属性 <code>t</code> 的类型必须为 <code>int32</code>, <code>float</code>, 或 <code>bool</code>:</li>
</ul>
<pre><code>REGISTER_OP("RestrictedTypeExample")
      .Attr("t: {int32, float, bool}");</code></pre>
<ul>
<li>
<p>这里有一些常见类型约束条件的快捷方式:</p>
<ul>
<li><code>numbertype</code>: 限制类型为数字类型, 即非 string 非 bool 的类型.</li>
<li><code>realnumbertype</code>: 与 <code>numbertype</code> 区别是不支持复杂类型.</li>
<li><code>quantizedtype</code>: 与 <code>numbertype</code> 区别是只支持量化数值 (quantized number type).</li>
</ul>
</li>
</ul>
<p>这些类型的列表在 <a "="" href="https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/framework/types.h" rel="nofollow"><code>tensorflow/core/framework/types.h</code></a>
文件中通过函数定义 (如 <code>NumberTypes()</code>).
本例中属性 <code>t</code> 必须为某种数字类型:</p>
<pre><code>REGISTER_OP("NumberType")
        .Attr("t: numbertype");</code></pre>
<p>对于这个 Op:</p>
<pre><code class="language-python">tf.number_type(t=tf.int32)  # 有效
tf.number_type(t=tf.bool)   # 无效</code></pre>
<ul>
<li><code>int &gt;= &lt;n&gt;</code>: 值必须是一个整数, 且取值大于等于 <code>&lt;n&gt;</code>, <code>&lt;n&gt;</code> 是一个自然数.</li>
</ul>
<p>例如, 下列 Op 注册操作指定了属性 <code>a</code> 的取值至少为 <code>2</code>.</p>
<pre><code>REGISTER_OP("MinIntExample")
      .Attr("a: int &gt;= 2");</code></pre>
<ul>
<li><code>list(&lt;type&gt;) &gt;= &lt;n&gt;</code>: 一个 <code>&lt;type&gt;</code> 类型列表, 列表长度必须大于等于 <code>&lt;n&gt;</code>.</li>
</ul>
<p>例如, 下面的 Op 注册操作指定属性 <code>a</code> 是一个列表, 列表中的元素类型是 <code>int32</code> 或  <code>float</code>列表长度至少为3.</p>
<pre><code>REGISTER_OP("TypeListExample")
      .Attr("a: list({int32, float}) &gt;= 3");</code></pre>
<p>通过添加 <code>= &lt;default&gt;</code> 到约束条件末尾, 给一个属性设置默认值 (使其在自动生成的代码里
变成可选属性), 如下:</p>
<pre><code>REGISTER_OP("AttrDefaultExample")
    .Attr("i: int = 0");</code></pre>
<p>默认值支持的语法将在最终 GraphDef 定义的 protobuf 表示中被使用.</p>
<p>下面是给所有类型赋予默认值的例子:</p>
<pre><code>REGISTER_OP("AttrDefaultExampleForAllTypes")
   .Attr("s: string = 'foo'")
   .Attr("i: int = 0")
   .Attr("f: float = 1.0")
   .Attr("b: bool = true")
   .Attr("ty: type = DT_INT32")
   .Attr("sh: shape = { dim { size: 1 } dim { size: 2 } }")
   .Attr("te: tensor = { dtype: DT_INT32 int_val: 5 }")
   .Attr("l_empty: list(int) = []")
   .Attr("l_int: list(int) = [2, 3, 5, 7]");</code></pre>
<p>请特别注意那些类型值里面包含的 <a #data-types="" href="tensorflow-zh/SOURCE/resources/dims_types.html"><code>DT_*</code> 名称</a>.</p>
<h3>多态 <a class="md-anchor" id="Polymorphism"></a></h3>
<h4>Type Polymorphism <a class="md-anchor" id="type-polymorphism"></a></h4>
<p>对于那些可以使用不同类型输入或产生不同类型输出的 Op, 可以注册 Op 时为输入/输出类型里指定一个<a href="#attrs">属性</a>.
一般紧接着, 会为每一个支持的类型注册一个 <code>OpKernel</code>.</p>
<p>例如, 除了 <code>int32</code> 外, 想要 <code>ZeroOut</code> Op 支持 <code>float</code>, 注册代码如下:</p>
<pre><code>REGISTER_OP("ZeroOut")
    .Attr("T: {float, int32}")
    .Input("to_zero: &lt;b&gt;T&lt;/b&gt;")
    .Output("zeroed: &lt;b&gt;T&lt;/b&gt;");</code></pre>
<p>这段 Op 注册代码现在指定了输入的类型必须为 <code>float</code> 或 <code>int32</code>, 而且
既然输入和输出制定了同样的类型 <code>T</code>, 输出也同样如此.</p>
<blockquote>
<p>一个命名建议:{#naming} 输入, 输出, 和属性通常使用 snake_case 命名法.
唯一的例外是属性被用作输入类型或是输入类型的一部分. 当添加到图中时, 这些属性
可以被推断出来, 因此不会出现在 Op 的函数里. 例如, 最后一个 ZeroOut 定义
生成的 Python 函数如下:</p>
</blockquote>
<pre><code class="language-python">def zero_out(to_zero, name=None):
   """...
   参数:
     to_zero: 一个 `Tensor`. 必须为下列类型之一:
         `float32`, `int32`.
     name: 操作的名字 (可选).

   返回值:
     一个 `Tensor`, 类型和 `to_zero` 一样.
   """</code></pre>
<blockquote>
<p>如果输入的 <code>to_zero</code> 是一个 <code>int32</code> 的tensor, 然后 <code>T</code> 将被自动
设置为 <code>int32</code> (实际上是 <code>DT_INT32</code>). 那些推导出的属性的名称字母全大写
或采用驼峰命名法.</p>
<p>下面是一个输出类型自动推断的例子, 读者可以对比一下:</p>
</blockquote>
<pre><code>REGISTER_OP("StringToNumber")
     .Input("string_tensor: string")
     .Output("output: out_type")
     .Attr("out_type: {float, int32}");
     .Doc(R"doc(
 Converts each string in the input Tensor to the specified numeric type.
 )doc");</code></pre>
<blockquote>
<p>在这种情况下, 用户需要在生成的 Python 代码中指定输出类型.</p>
</blockquote>
<pre><code class="language-python">def string_to_number(string_tensor, out_type=None, name=None):
   """将输入 Tensor 中的每一个字符串转化成指定的数字类型

   参数:
     string_tensor: 一个 `string` 类型的 `Tensor`.
     out_type: 一个可选的 `tf.DType`, 取值为 `tf.float32, tf.int32`.
       默认值是 `tf.float32`.
     name: 操作的名称 (可选).

   返回值:
     一个 `out_type` 类型的 `Tensor`.
   """</code></pre>
<pre><code> #include "tensorflow/core/framework/op_kernel.h"
class ZeroOutInt32Op : public OpKernel {
  // 和之前一样
};
class ZeroOutFloatOp : public OpKernel {
 public:
  explicit ZeroOutFloatOp(OpKernelConstruction * context)
      : OpKernel(context) {}
  void Compute(OpKernelContext * context) override {
    // 获取输入 tensor
    const Tensor&amp; input_tensor = context-&gt;input(0);
    auto input = input_tensor.flat&lt;float&gt;();
    // 创建一个输出 tensor
    Tensor * output = NULL;
    OP_REQUIRES_OK(context,
                    context-&gt;allocate_output(0, input_tensor.shape(), &amp;output));
    auto output_flat = output-&gt;template flat&lt;float&gt;();
    // 设置输出 tensor 的所有元素为 0
    const int N = input.size();
    for (int i = 0; i &amp;lt; N; i++) {
      output_flat(i) = 0;
    }&lt;br/&gt;
    // 保留第一个输入值
    if (N &amp;gt; 0) output_flat(0) = input(0);
  }
};
// 注意, TypeConstraint&lt;int32&gt;("T") 意味着属性 "T" (在上面 Op 注册代码中
// 定义的) 必须是 "int32", 才能实例化. 
REGISTER_KERNEL_BUILDER(
    Name("ZeroOut")
    .Device(DEVICE_CPU)
    .TypeConstraint&amp;lt;int32&amp;gt;("T"),
    ZeroOutOpInt32);
REGISTER_KERNEL_BUILDER(
    Name("ZeroOut")
    .Device(DEVICE_CPU)
    .TypeConstraint&lt;float&gt;("T"),
    ZeroOutFloatOp);</code></pre>
<blockquote>
<p>为了保持<a href="#backwards-compatibility">向后兼容性</a>, 你在为一个
已有的 op 添加属性时, 必须指定一个<a href="#default-values-constraints">默认值</a>:</p>
</blockquote>
<pre><code>REGISTER_OP("ZeroOut")
  .Attr("T: {float, int32} = DT_INT32")
  .Input("to_zero: T")
  .Output("zeroed: T")</code></pre>
<p>如果需要添加更多类型, 例如 <code>double</code>:</p>
<pre><code>REGISTER_OP("ZeroOut")
    .Attr("T: {float, double, int32}")
    .Input("to_zero: T")
    .Output("zeroed: T");</code></pre>
<p>为了避免为新增的类型写冗余的 <code>OpKernel</code> 代码, 通常可以写一个 C++ 模板作为替代.
当然, 仍然需要为每一个重载版本定义一个 keneral 注册 (<code>REGISTER\_KERNEL\_BUILDER</code> 调用).</p>
<pre><code>template &lt;typename T&gt;;
class ZeroOutOp : public OpKernel {
 public:
    explicit ZeroOutOp(OpKernelConstruction* context) : OpKernel(context) {}
  void Compute(OpKernelContext* context) override {
    // 获取输入 tensor
     const Tensor&amp; input_tensor = context-&gt;input(0);
    auto input = input_tensor.flat&lt;T&gt;();
    // 创建一个输出 tensor
      Tensor* output = NULL;
    OP_REQUIRES_OK(context,
                   context-&gt;allocate_output(0, input_tensor.shape(), &amp;output));
    auto output_flat = output-&gt;template flat&lt;T&gt;();
    // 设置输出 tensor 的所有元素为 0
   const int N = input.size();
    for (int i = 0; i &lt; N; i++) {
      output_flat(i) = 0;
    }
    // Preserve the first input value
    if (N &gt; 0) output_flat(0) = input(0);
  }
};
};&lt;br/&gt;
// 注意, TypeConstraint&lt;int32&gt;("T") 意味着属性 "T" (在上面 Op 注册代码中
// 定义的) 必须是 "int32", 才能实例化. &lt;/b&gt;
REGISTER_KERNEL_BUILDER(
    Name("ZeroOut")
    .Device(DEVICE_CPU)
    .TypeConstraint&lt;int32&gt;("T"),
    ZeroOutOp&lt;int32&gt;);
REGISTER_KERNEL_BUILDER(
    Name("ZeroOut")
    .Device(DEVICE_CPU)
    .TypeConstraint&lt;float&gt;("T"),
    ZeroOutOp&lt;float&gt;);
REGISTER_KERNEL_BUILDER(
    Name("ZeroOut")
    .Device(DEVICE_CPU)
    .TypeConstraint&lt;double&gt;("T"),
    ZeroOutOp&lt;double&gt;);</code></pre>
<p>如果有很多重载版本, 可以将注册操作通过一个宏来实现.</p>
<pre><code> #include "tensorflow/core/framework/op_kernel.h"
 #define REGISTER_KERNEL(type)                                       \
  REGISTER_KERNEL_BUILDER(                                          \
      Name("ZeroOut").Device(DEVICE_CPU).TypeConstraint&lt;type&gt;("T"), \
      ZeroOutOp&lt;type&gt;)
REGISTER_KERNEL(int32);
REGISTER_KERNEL(float);
REGISTER_KERNEL(double);
 #undef REGISTER_KERNEL</code></pre>
<p>取决于注册 kernel 使用哪些类型, 你可能可以使用<a "="" href="https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/framework/register_types.h" rel="nofollow"><code>tensorflow/core/framework/register_types.h</code></a>
提供的宏:</p>
<pre><code> #include "tensorflow/core/framework/op_kernel.h"
 #include "tensorflow/core/framework/register_types.h"
REGISTER_OP("ZeroOut")
    .Attr("T: realnumbertype")
    .Input("to_zero: T")
    .Output("zeroed: T");
template &lt;typename T&gt;
class ZeroOutOp : public OpKernel { ... };
 #define REGISTER_KERNEL(type)                                       \
  REGISTER_KERNEL_BUILDER(                                          \
      Name("ZeroOut").Device(DEVICE_CPU).TypeConstraint&lt;type&gt;("T"), \
      ZeroOutOp&lt;type&gt;)
TF_CALL_REAL_NUMBER_TYPES(REGISTER_KERNEL);
 #undef REGISTER_KERNEL</code></pre>
<h4>列表输入和输出 <a class="md-anchor" id="list-input-output"></a></h4>
<p>除了能够使用不同类型的 tensor 作为输入或输出, Op 还支持使用多个 tensor 作为输入或输出.</p>
<p>在接下来的例子里, 属性 <code>T</code> 存储了一个类型<em>列表</em>, 并同时作为输入 <code>in</code> 和输出 <code>out</code> 的类型.
输入和输出均为指定类型的 tensor 列表. 既然输入和输出的类型均为 <code>T</code>, 它们的 tensor 数量和类型
是一致的.</p>
<pre><code>REGISTER_OP("PolymorphicListExample")
    .Attr("T: list(type)")
    .Input("in: T")
    .Output("out: T");</code></pre>
<p>可以为列表中可存放的类型设置约束条件. 在下一个例子中, 输入是 <code>float</code> 和
<code>double</code> 类型的 tensor 列表. 例如, 这个 Op 可接受的
输入类型为 <code>(float, double, float)</code> 的数据, 且在此情况下, 输出类型同样
为 <code>(float, double, float)</code>.</p>
<pre><code>REGISTER_OP("ListTypeRestrictionExample")
    .Attr("T: list({float, double})")
    .Input("in: T")
    .Output("out: T");</code></pre>
<p>如果想要一个列表中的所有 tensor 是同一类型, 你需要写下列代码:</p>
<pre><code>REGISTER_OP("IntListInputExample")
    .Attr("N: int")
    .Input("in: N * int32")
    .Output("out: int32");</code></pre>
<p>这段代码接受 <code>int32</code> tensor 列表, 并用一个 <code>int</code> 属性 <code>N</code>
来指定列表的长度.</p>
<p>这也可用于<a href="#type-polymorphism">类型推断</a>. 在下一个例子中,
输入是一个 tensor 列表, 长度为 <code>"N"</code>, 类型为 <code>"T"</code>, 输出是单个 <code>"T"</code> 的 tensor:</p>
<pre><code>REGISTER_OP("SameListInputExample")
    .Attr("N: int")
    .Attr("T: type")
    .Input("in: N * T")
    .Output("out: T");</code></pre>
<p>默认情况下, tensor 列表的最小长度为1. 这个约束条件可以通过
<a href="#default-values-constraints">为指定的属性增加一个 <code>"&gt;="</code> 约束</a>来变更:</p>
<pre><code>REGISTER_OP("MinLengthIntListExample")
    .Attr("N: int &gt;= 2")
    .Input("in: N * int32")
    .Output("out: int32");</code></pre>
<p>同样的语法也适用于 <code>"list(type)"</code> 属性:</p>
<pre><code>REGISTER_OP("MinimumLengthPolymorphicListExample")
    .Attr("T: list(type) &gt;= 3")
    .Input("in: T")
    .Output("out: T");</code></pre>
<h3>输入和输出 <a class="md-anchor" id="AUTOGENERATED-inputs-and-outputs"></a></h3>
<p>总结一下上述内容, 一个 Op 注册操作可以指定多个输入和输出:</p>
<pre><code>REGISTER_OP("MultipleInsAndOuts")
    .Input("y: int32")
    .Input("z: float")
    .Output("a: string")
    .Output("b: int32");</code></pre>
<p>每一个输入或输出形式如下:</p>
<pre><code>&lt;name&gt;: &lt;io-type-expr&gt;</code></pre>
<p>其中, <code>&lt;name&gt;</code> 以字母打头, 且只能由数字, 字母和下划线组成. <code>&lt;io-type-expr&gt;</code> 可以是
下列类型表达式之一:</p>
<ul>
<li><code>&lt;type&gt;</code>, 一个合法的输入类型, 如 <code>float</code>, <code>int32</code>, <code>string</code>. 这可用于指定给定类型的单个 tensor.</li>
</ul>
<p>参见<a #data-types="" href="tensorflow-zh/SOURCE/resources/dims_types.html">合法 Tensor 类型列表</a>.</p>
<pre><code>REGISTER_OP("BuiltInTypesExample")
      .Input("integers: int32")
      .Input("complex_numbers: scomplex64");</code></pre>
<ul>
<li><code>&lt;attr-type&gt;</code>, 一个<a href="#attrs">属性</a>和一个类型 <code>type</code> 或类型列表 <code>list(type)</code>(可能
包含类型限制). 该语法可实现<a href="#Polymorphism">多态 Op</a>.</li>
</ul>
<pre><code>REGISTER_OP("PolymorphicSingleInput")
      .Attr("T: type")
      .Input("in: T);
REGISTER_OP("RestrictedPolymorphicSingleInput")
      .Attr("T: {int32, int64}")
      .Input("in: T);</code></pre>
<p>将属性的类型设置为 <code>list(type)</code> 将允许你接受一个序列的 tensor.</p>
<pre><code>REGISTER_OP("ArbitraryTensorSequenceExample")
      .Attr("T: list(type)")
      .Input("in: T")
      .Output("out: T");
REGISTER_OP("RestrictedTensorSequenceExample")
      .Attr("T: list({int32, int64})")
      .Input("in: T")
      .Output("out: T");</code></pre>
<p>注意, 输入和输出均为 <code>T</code>, 意味着输入和输出的类型与数量均相同.</p>
<ul>
<li><code>&lt;number&gt; * &lt;type&gt;</code>, 一组拥有相同类型的 tensor, <code>&lt;number&gt;</code> 是一个 <code>int</code> 类型属性的名称.
<code>&lt;type&gt;</code> 可以是<a #data-types="" href="tensorflow-zh/SOURCE/resources/dims_types.html">一个类似于 <code>int32</code> 和 <code>float</code> 的特定类型</a>,
或者一个 <code>type</code> 类型属性的名字. 前者的例子如下, 该例子接受一个 <code>int32</code> tensor 列表作为 Op 输入:</li>
</ul>
<pre><code>REGISTER_OP("Int32SequenceExample")
      .Attr("NumTensors: int")
      .Input("in: NumTensors * int32")</code></pre>
<p>后者的例子如下, 该例子接受一个泛型 tensor 列表作为 Op 输入:</p>
<pre><code>REGISTER_OP("SameTypeSequenceExample")
      .Attr("NumTensors: int")
      .Attr("T: type")
      .Input("in: NumTensors * T")</code></pre>
<ul>
<li>Tensor 的引用表示为 <code>Ref(&lt;type&gt;)</code>, 其中 <code>&lt;type&gt;</code> 是上述类型之一.</li>
</ul>
<blockquote>
<p>一个命名建议: 当使用属性表示一个输入的类型时, 该类型可以被推断出来. 实现该特性, 将需要推断
的类型用大写名称表示 (如 <code>T</code> 或 <code>N</code>), 其它的输入, 输出, 和属性像使用函数参数一样使用这些
大写名称. 参见之前的<a href="#naming">命名建议</a>章节查看更多细节.</p>
</blockquote>
<p>更多细节参见 <a "="" href="https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/framework/op_def_builder.h" rel="nofollow"><code>tensorflow/core/framework/op_def_builder.h</code></a>.</p>
<h3>向后兼容性 <a class="md-anchor" id="AUTOGENERATED-backwards-compatibility"></a></h3>
<p>通常, 对规范的改变必须保持向后兼容性: Op 使用新规范后, 需保证使用旧规范构造的序列化 GraphDef 仍能正确工作.</p>
<p>下面是几种保持向后兼容性的方式:</p>
<ol>
<li>任何添加到 Op 的新属性必须有默认值, 且默认值下的行为有明确定义. 将一个非多态的操作变为多态操作,
你<em>必须</em>为新的类型属性赋予默认值, 以保持原始的函数签名. 例如, 有如下操作:</li>
</ol>
<pre><code>REGISTER_OP("MyGeneralUnaryOp")
       .Input("in: float")
       .Output("out: float");</code></pre>
<p>可以通过下述方式将其变为多态, 且保持向后兼容性:</p>
<pre><code>REGISTER_OP("MyGeneralUnaryOp")
       .Input("in: T")
       .Output("out: T")
       .Attr("T: numerictype = float");</code></pre>
<p>1.放宽一个属性的约束条件是安全的. 例如, 你可以将 <code>{int32, int64}</code> 变为 <code>{int32, int64, float}</code>,
或者, 将 <code>{"apple", "orange"}</code> 变为 <code>{"apple", "banana", "orange"}</code>.</p>
<p>2.通过给 Op 名称添加一些项目中唯一的标识作为前缀, 来为新建的 Op 添加命名空间. 命名空间
可以预防你的 Op 与 TensorFlow 未来版本里的内置 Op 产生命名冲突.</p>
<p>3.超前计划! 尝试着去预测 Op 未来的的用途, 超前设计, 毕竟, 一些签名的变更无法保证兼容性
(例如, 增加新的输入, 或将原来的单元素输入变成一个列表).</p>
<p>如果不能以兼容的方式改变一个操作, 那就创建一个全新的操作, 来实现所需功能.</p>
<h2 id="6ddff050dc9acfe5fef9b5d24ed35efe">GPU 支持 <a class="md-anchor" id="mult-archs"></a></h2>
<p>你可以实现不同的 OpKernel, 将其中之一注册到 GPU, 另一个注册到 GPU, 正如<a href="#Polymorphism">为不同的类型注册 kernel </a>一样.
<a "="" href="https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/kernels/" rel="nofollow"><code>tensorflow/core/kernels/</code></a> 中有一些 GPU 支持的例子.
注意, 一些 kernel 的 CPU 版本位于 <code>.cc</code> 文件, GPU 版本位于 <code>_gpu.cu.cc</code> 文件, 共享的代码位于 <code>.h</code> 文件.</p>
<p>例如, <a #pad="" href="tensorflow-zh/SOURCE/api_docs/python/array_ops.html"><code>pad</code> op</a> 除了 GPU kernel 外的其它代码
均在 <a "="" href="https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/kernels/pad_op.cc" rel="nofollow"><code>tensorflow/core/kernels/pad_op.cc</code></a> 中. GPU kernel 位于 <a "="" href="https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/kernels/pad_op_gpu.cu.cc" rel="nofollow"><code>tensorflow/core/kernels/pad_op_gpu.cu.cc</code></a>,
共享的一个模板类代码定义在 <a "="" href="https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/kernels/pad_op.h" rel="nofollow"><code>tensorflow/core/kernels/pad_op.h</code></a>.
需要注意的事情是, 即使使用 <code>pad</code> 的 GPU 版本时, 仍然需要将 <code>"paddings"</code> 输入放置到内存中.
为了实现这一点, 将输入或输出标记为必须保存在内存中, 为 kernel 注册一个 <code>HostMemory()</code> 调用.
如下:</p>
<pre><code> #define REGISTER_GPU_KERNEL(T)                         \
REGISTER_KERNEL_BUILDER(Name("Pad")                  \
                              .Device(DEVICE_GPU)      \
                              .TypeConstraint&lt;T&gt;("T")  \
                              .HostMemory("paddings"), \
                          PadOp&lt;GPUDevice, T&gt;)</code></pre>
<h2 id="ba7d108ee245657b7d009d12724d3a2e">使用 Python 实现梯度 <a class="md-anchor" id="AUTOGENERATED-implement-the-gradient-in-python"></a></h2>
<p>给定一个 Op 组成的图, TensorFlow 使用自动微分 (反向传播) 来添加新的 Op 以表示梯度运算, 同时
不影响已有的 Op (参见<a #gradient-computation="" href="tensorflow-zh/SOURCE/api_docs/python/train.html">梯度运算</a>).
为了使自动微分能够与新的 Op 协同工作, 必须注册一个梯度函数, 从 Op 的输入计算梯度, 并返回代表
梯度值的输出.</p>
<p>数学上, 如果一个 Op 计算 \(y = f(x)\), 注册的梯度 Op 通过以下链式法则, 将 \(\partial / \partial y\)
的梯度运算转化为 \(\partial / \partial x\) 的梯度运算.</p>
<p>$$\frac{\partial}{\partial x}
= \frac{\partial}{\partial y} \frac{\partial y}{\partial x}
= \frac{\partial}{\partial y} \frac{\partial f}{\partial x}.$$</p>
<p>在 <code>ZeroOut</code> 的例子中, 输入中只有一个项会影响输出, 所以, 代表输入的梯度值的 tensor 也只有
一个输入项. 如下所示:</p>
<pre><code class="language-python">from tensorflow.python.framework import ops
from tensorflow.python.ops import array_ops
from tensorflow.python.ops import sparse_ops

@ops.RegisterGradient("ZeroOut")
def _zero_out_grad(op, grad):
  """`zero_out` 的梯度.

  参数:
    op: 欲进行微分的 `zero_out` `操作`, 可以用于获取原始 Op 的输入和输出.
    grad: 代表 `zero_out` 输出的梯度 Op.

  返回:
    代表输入 `zero_out` 的微分.
  """
  to_zero = op.inputs[0]
  shape = array_ops.shape(to_zero)
  index = array_ops.zeros_like(shape)
  first_grad = array_ops.reshape(grad, [-1])[0]
  to_zero_grad = sparse_ops.sparse_to_dense(index, shape, first_grad, 0)
  return [to_zero_grad]  # 单个 Tensor 的列表, 既然只有一个输入</code></pre>
<p>使用 <a #registergradient="" href="tensorflow-zh/SOURCE/api_docs/python/framework.html"><code>ops.RegisterGradient</code></a>
注册梯度函数需要注意的一些细节:</p>
<ul>
<li>
<p>对于仅有一个输出的 Op, 梯度函数使用 <a #operation="" href="tensorflow-zh/SOURCE/api_docs/python/framework.html"><code>Operation</code></a> <code>op</code>
和一个 <a #tensor="" href="tensorflow-zh/SOURCE/api_docs/python/framework.html"><code>Tensor</code></a> <code>grad</code> 作为参数, 并从
<a #operation.inputs="" href="tensorflow-zh/SOURCE/api_docs/python/framework.html"><code>op.inputs[i]</code></a>,
<a #operation.outputs="" href="tensorflow-zh/SOURCE/api_docs/python/framework.html"><code>op.outputs[i]</code></a>,
和 <code>grad</code> 构建新的 Op. 属性的信息可以通过 <a #operation.get_attr="" href="tensorflow-zh/SOURCE/api_docs/python/framework.html"><code>op.get_attr</code></a> 获取.</p>
</li>
<li>
<p>如果 Op 有多个输出, 梯度函数将使用 <code>op</code> 和 <code>grads</code> 作为参数, 其中, <code>grads</code> 是一个
梯度 Op 的列表, 为每一个输出计算梯度. 梯度函数的输出必须是一个 <code>Tensor</code> 对象列表, 对应到
每一个输入的梯度.</p>
</li>
<li>
<p>如果没有为一些输入定义梯度, 譬如用作索引的整型, 这些输入返回的梯度为 <code>None</code>. 举一个例子,
如果一个 Op 的输入为一个浮点数 tensor <code>x</code> 和一个整型索引 <code>i</code>, 那么梯度函数将返回
<code>[x_grad, None]</code>.</p>
</li>
<li>如果梯度对于一个 Op 来说毫无意义, 使用 <code>ops.NoGradient("OpName")</code> 禁用自动差分.</li>
</ul>
<p>注意当梯度函数被调用时, 作用的对象是数据流图中的 Op, 而不是 tensor 数据本身. 因此, 只有在图运行时,
梯度运算才会被其它 tensorflow Op 的执行动作所触发.</p>
<h2 id="61e97fc5e09a6a6080d2f885031b575f">在 Python 中实现一个形状函数 <a class="md-anchor" id="AUTOGENERATED-implement-a-shape-function-in-python"></a></h2>
<p>TensorFlow Python API 有一个 "形状推断" 功能, 可以不执行图就获取 tensor 的形状信息.
形状推断功能藉由每一个 Op 类型注册的 "形状函数" 来支持, 该函数有两个规则: 假设所有输入的
形状必须是兼容的, 以及指定输出的形状. 一个形状函数以一个 <a #operation="" href="tensorflow-zh/SOURCE/api_docs/python/framework.html"><code>Operation</code></a>
作为输入, 返回一个 <a #tensorshape="" href="tensorflow-zh/SOURCE/api_docs/python/framework.html"><code>TensorShape</code></a>
对象列表 (每一个输出一个对象). 使用 <a #registershape="" href="tensorflow-zh/SOURCE/api_docs/python/framework.html"><code>tf.RegisterShape</code> 装饰器</a>
注册形状函数. 例如, <a href="#define_interface">上文定义的 <code>ZeroOut</code> Op</a> 的形状函数如下:</p>
<pre><code class="language-python">@tf.RegisterShape("ZeroOut"):
def _zero_out_shape(op):
  """ZeroOut Op 的形状函数.

  这是 ZeroOut 形状函数的无约束版本, 为每一个输出产生的形状和对应的输入一样. 
  """
  return [op.inputs[0].get_shape()]</code></pre>
<p>一个形状函数也可以约束输入的形状. 下面是 <a href="#Validation">ZeroOut 形状函数的 vector 输入约束</a>版本:</p>
<pre><code class="language-python">@tf.RegisterShape("ZeroOut"):
def _zero_out_shape(op):
  """ZeroOut Op 的形状函数.

  这是 ZeroOut 形状函数的约束版本, 要输入的 rank 必须是 1 (即使一个 vector).
  """
  input_shape = op.inputs[0].get_shape().with_rank(1)
  return [input_shape]</code></pre>
<p>如果 Op 是<a href="#Polymorphism">多输入的多态 Op</a>, 使用操作的属性来决定需要检查的形状数量:</p>
<pre><code>@tf.RegisterShape("IntListInputExample")
def _int_list_input_example_shape(op):
  """ "IntListInputExample" Op 的形状函数.

  所有的输入和输出是同大小的矩阵.
  """
  output_shape = tf.TensorShape(None)
  for input in op.inputs:
    output_shape = output_shape.merge_with(input.get_shape().with_rank(2))
  return [output_shape]</code></pre>
<p>既然形状推断是一个可选的特性, 且 tensor 的形状可能动态变化, 形状函数必须足够健壮, 能够处理任意
输入形状信息缺失的情形. <a href="tensorflow-zh/SOURCE/api_docs/python/framework.html"><code>merge_with</code></a> 方法能够帮助
调用者判断两个形状是否是一样的, 即使两个形状的信息不全, 该函数同样有效. 所有的<a "="" href="https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/python/ops/" rel="nofollow">标准 Python Op</a>
的形状函数都已经定义好了, 并且已经有很多不同的使用示例.</p>
<blockquote>
<p>原文：<a "="" href="http://www.tensorflow.org/how_tos/adding_an_op/index.html#adding-a-new-op" rel="nofollow">Adding a New Op</a>  翻译：<a "="" href="https://github.com/PFZheng" rel="nofollow">@doc001</a> 校对：<a "="" href="https://github.com/ZHNathanielLee" rel="nofollow">@ZHNathanielLee</a></p>
</blockquote>
</div>
    </body></html>